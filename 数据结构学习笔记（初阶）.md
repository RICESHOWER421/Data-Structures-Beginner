# 1.什么是数据结构？

  数据结构是计算机存储，组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合



# 2.什么是算法？

   算法就是定义良好的计算过程，他取一个或一组的值为输入，并产生一个或一组值作为输出，简单来说
  就是一系列的计算步骤，用来将输入数据转化成输出结果。



# 3.算法的复杂度

  衡量一个算法的好坏，一般是从时间和空间两个维度来衡量的，分别为时间复杂度和空间复杂度
时间复杂度主要衡量的是一个算法的运行快慢，而空间复杂度主要是衡量一个算法运行所需要的额外空间
  目前更加关注时间复杂度，不怎么关注空间复杂度



## 时间复杂度的概念：

在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间，一个算法执行所消耗的时间
，从理论上说，是不能算出来的，只有把程序放在机器上跑起来，才能知道。
环境不同，具体运行时间就不同

一个算法所花费的时间与其语句的执行次数成正比例，算法的基本操作的执行次数，为算法的时间复杂度
即：找到某条基本语法与问题规模N之间的数学表达式，就是算出了该算法的时间复杂度

例：

```c
int main()
{
	int i = 0, j = 0;    //嵌套循环
	int count = 0;
	for (i = 0; i < N; i++)
	{
		for (j = 0; j < N; j++)
		{
			count++;
		}
	}

    for (i = 0; i < 2 * N; i++)
    {
        count++;
    }

    int num = 10;
    while (num--)
    {
        count++;
    }

    printf("%d",count);

    return 0;

}
```

在该段代码中，时间复杂度为F(N) = N*N + 2 * N + 10，打印出的count结果就是时间复杂度的大小
当N = 10时，F(N) = 130
当N = 100时，F(N) = 10210
以此类推

同时我们也能发现，在该串代码中，随着N的增大，2*N + 10对F(N)结果的影响是越来越小的
在实际中，我们计算时间复杂度时并不一定要计算精确的执行次数，，而只需要大概执行次数，那么我们就会使用到大O的渐进表示法
就像上面的这串代码，该时间复杂度就可以表示为O(N^2)

## 大O的渐进表示法

大O符号：是用于描述函数渐进行为的数学符号
推导大O阶方法：

**①用常数1取代运行时间中的所有加法常数**

**②在修改后的运行次数函数中，只保留最高阶项**

**③如果最高阶项存在且不是1，则去除与这个项目相乘的常数，得 到的结果就是大O阶（如当一串代码的时间复杂度为2 * N + 10,则忽略+10和2，只留O(N)）**



例:

```C
#define N 10
#define M 20
int main()
{
	int i = 0;
	int count = 0;
	for (i = 0; i < N; i++)
	{
		count++;
	}

    for(i = 0; i < M; i++)
    {
        count++;
    }
    printf("%d",count);
    return 0;

}
```

此时用大O的渐进表示法表示该时间复杂度则为O(M + N)(这种情况仅限于M和N已知的情况) 
出现这种情况时：
当M远大于N时 -> O(M)
当N远大于M时 -> O(N)
当M和N差不多大时 -> O(M) 或者 O(N)

当算法随着输入的不同，时间复杂度不同，时间复杂度做悲观预期，看最坏的情况（很少算平均）

斐波那契数列的时间复杂度:

```C
long long Fib(size_t N)
{
   if(N < 3)
   {
       return 1;
   }
   return Fib(N - 1) + Fib(N - 2);
}
```

大O时间复杂度：O(2 ^ n)
实际时间复杂度： Fib(N) = 2 ^ 0 + 2 ^ 1 +...... + 2 ^ (N - 1) - X(缺少的一些函数调用次数)

二分查找时间复杂度：

```C
int main()
{
	//二分查找的基本，一个有序数列，这里给的是升序数列
	int nums[10] = { 1,2,3,4,5,6,7,8,9,10 };
	//算数组大小
	int size = sizeof(nums) / sizeof(nums[0]);
	//从最左边的坐标开始按照要求往右移
	int left = 0;
	//从最右边的坐标开始按照要求往左移
	int right = size - 1;
	//需要查找的数字
	int num = 0;
	scanf("%d",&num);
	//判断是否找到我们所需要找到的值，如果找到了值为1，否则为0
	int temp = 0;
	//循环，当左下标和右下标相遇时停止循环
	while (left <= right)
	{
		//中间值下标
		int mid = (left + right) / 2;
		//在二分查找过程中中间值正好等于我们所要的值，返回下标并改变temp值
		if (nums[mid] == num)
		{
			printf("找到了！下标为：%d",mid);
			temp = 1;
			break;
		}
		//在二分查找过程中中间值大于我们所要找的值，说明位于中间值左边下标的值可以不用寻找（包括中间值），直接将left下标拉到mid下标的下一位
		else if (nums[mid] < num)
		{
			left = mid + 1;
		}
		//在二分查找过程中中间值小于我们所要找的值，说明位于中间值右边下标的值可以不用寻找（包括中间值），直接将right下标拉到mid下标的上一位
		else
		{
			right = mid - 1;
		}
	}
	//如果没有找到，temp值不会改变仍为0，打印结果
	if (temp == 0)
	{
		printf("没找到！");
	}
	return 0;
}
```

大O时间复杂度：O(log2  N)
解释：
每找一次，我们就能筛出一半我们不需要查找的数据，假设我们需要查X次，该有序数组中含有N个数据。现在考虑的是二分查找中最坏的情况：找不到数据
N / 2 / 2 / 2 / 2 /................(由于查一次就会筛选掉一半的数据，所以/2的个数取决于X的次数) = 1
结果为N = 2 ^ X --> X = log2 N



## 空间复杂度概念：

空间复杂度也是一个数学表达式，是对一个算法在运行过程中临时占用存储空间大小的量度

空间复杂度不是程序占用多少byte的空间，因为这也没啥意义，所以空间复杂度算的是变量的个数。
空间复杂度的计算规则基本跟时间复杂度类似，也是用大O渐进表示法

注意：函数运行时所需要的栈空间（存储参数，局部变量，一些寄存器信息等）在编译期间已经搞定好了，因此
空间复杂度主要通过函数在运行时候显示申请的额外空间来确定。

**空间是可以重复利用的，可以重复运用，可以累计**
**而时间不可以，不能重复运用，不可以累计**

例如：

```C
long long Fib(size_t N)
{
   if(N < 3)
   {
       return 1;
   }
   return Fib(N - 1) + Fib(N - 2);
}
```

空间复杂度为O(N)。
因为在进行函数递归建立栈帧时（如图所示）

![](C:\Users\34289\Desktop\learning\code learning material\数据结构与算法\数据结构（初阶）示意图\斐波那契数列空间复杂度示意图.png)

由于空间是可以重复运用的，所以在执行Fib(N - 1)时，他先会一直执行到Fib(1)，执行结束后再执行Fib(N - 2)。但是在执行Fib(N - 1)时，Fib(N - 2)的栈帧就已经创立了，所以会直接运用上一次执行已经创建好的栈帧，如此一直执行下去，所以最后空间复杂度就是O(N)。



# 4.线性表

线性表时n个具有相同特性的数据元素的有限序列。线性表是一种在实际中广泛使用的数据结构。常见的线性表：顺序表、链表、栈、队列、字符串...



线性表在逻辑上是线性结构、也就是说连续的一条直线、但是在物理结构上并不一定是连续的，线性表在物理上存储时，通常以数组和链表结构的形势存储。



## 1.顺序表

### ①概念及结构

顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储，存数组上完成数据的增删查改。



### ②顺序表的问题

1.头部和中部插入的效率都不行 时间复杂度为O(N)

2.增容需要申请新空间，拷贝数据，释放旧空间。会有不小的损耗

3.增容一般是呈2倍的增长，势必会有一定的空间浪费。比如当前容量为100，满了扩容容量就为200，此时再插入5个元素就会造成95个空间浪费情况。



## ③顺序表的优点

1.尾插尾删足够快

2.下标的随机访问和修改

3.支持随机访问（可以用下标直接访问某个值）

**4.cpu高速缓存利用率高**



## 2.链表

### ①概念及结构

概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的**逻辑顺序**是通过链表中的指针链接次序实现的。 

![](C:\Users\34289\Desktop\learning\code learning material\数据结构与算法\数据结构（初阶）示意图\链表理解图.png)

### ②链表的优点

1.按需申请空间，不用了就释放空间（更加合理的使用空间）

2.头部中间插入删除数据，不需要挪动数据

3.不存在空间浪费



### ③链表的缺点

1.每一个数据，都要存一个指针取链接后面的节点，不支持随机访问。

2.链表存储一个值，同时要存储链接指针，也有一定消耗（但是问题不大）

**4.cpu高速缓存利用率低**





### ④单链表

单链表的缺陷比较多，只靠单纯的单链表进行增删查改意义不大

但是：
1.很多OJ题考查的都是单链表

2.单链表更多的是去更复杂的数据结构的子结构，比如哈希表、邻接表



链表存储数据一般得看双向链表。



## 3.环形链表

### ①怎么证明该链表是环形链表？

结论：使用快慢指针进行遍历，假设慢指针用slow表示，一次向前经过一个数据，快指针用fast表示，一次向前经过两个数据。那么，在两个指针都进入到环形链表的节点时，两指针如果相遇了，那么就可以证明该链表就是环形链表



证明：因为当双指针同时进入到环形节点后时，快慢指针之间的差距一直会依次减1，最后实现相遇。

![](C:\Users\34289\Desktop\learning\code learning material\数据结构与算法\数据结构（初阶）示意图\寻找环形链表的节点1.png)



那么，我们快指针所经过的数据可以是N吗？（N > 2 && N是正整数） 答案是不确定的

![](C:\Users\34289\Desktop\learning\code learning material\数据结构与算法\数据结构（初阶）示意图\快慢指针解决环形链表问题2.png)

###  ②怎么寻找环形链表的节点？

**一、根据公式可巧妙计算出环形链表的节点位置（不需要改变链表结构）**

![](C:\Users\34289\Desktop\learning\code learning material\数据结构与算法\数据结构（初阶）示意图\寻找环形链表的节点1.png)

**二、在meet节点处进行解环处理（将meet的next节点先用一个指针存储（假设为list），再将其制空处理），然后在用两个指针，一个从head开始，一个从list开始，最后变成链表相交问题。相交的位置就是环形链表的节点。（需要改变链表结构）**

![](C:\Users\34289\Desktop\learning\code learning material\数据结构与算法\数据结构（初阶）示意图\寻找环形链表的节点2.png)

## 4.双向链表

### 一、链表总结

链表分为**单向**、**双向**、**有头**、**无头**、**循环**、**非循环**链表。

经过排列组合，一共有**八种**链表结构。

其中最为常用的为**无头单向非循环链表**（结构最简单）和**带头双向循环链表**（结构最复杂）





### 二、双向链表的结构体



`typedef int DLTDataType;`

`typedef struct SDListNode`
`{`
	`DLTDataType date;`
	`struct DListNode* next;`
	`struct DListNode* prev;`
`}DLT;`



**新增指针prev可以指向该节点前一个数据**



# 5.栈和队列

## 1.栈

### 1.1栈的概念及结构

   栈是一种特殊的线性表，其只允许在固定的一段进行插入和删除元素的操作。**进入数据插入和删除操作的一端称为栈顶，另一端称为栈底。**栈中的数据元素遵守**后进先出LIFO**（Last in First Out）原则。



压栈：栈的插入操作叫做进栈/压栈/入栈，**入数据在栈顶**。

出栈：栈的删除操作叫做出栈，**出数据也在栈顶**。



## 2.队列

### 2.1队列的概念及结构

队列：只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有**先进先出FIFO**（First in First Out）的特点。

入队列：进行输入操作的一端称为**队尾**。

出队列：进行删除操作的一端称为**队头**。



# 6.树

## 一、树的概念

理解辅助图：

![](C:\Users\34289\Desktop\learning\code learning material\数据结构与算法\数据结构（初阶）示意图\树的结构图.png)

1.结点的度：一个结点含有的子树的个数称为该结点的度。比如：上图树结构A结点的度数为6。

2.叶结点或终端结点：度为0的结点称为叶结点或终端结点。比如：上图树结构B、C、K、L等结点都是叶结点或终端结点。

3.非终端结点或分支结点：度不为0的结点。比如：上图树结构D、E、F、G等都属于分支结点或终端结点。

4.双亲结点或父结点：一个结点存在子结点，那么该结点称为其子结点的父结点。比如：上图树结构A是B的父结点或双亲结点。

5.孩子结点或子结点：一个结点含有子树的根结点称为该结点的子结点。比如：上图树结构B是A的子结点或孩子结点。

6.兄弟结点：具有相同父结点的结点互称为兄弟结点。比如：上图树结构B、C是兄弟结点。

7.树的度：一棵树中，最大的结点的度称为树的度。比如：上图树结构树的度是6（A结点的度）。

8.结点的层次：从根开始定义起，根为第一层、根的子结点为第二层。以此类推。

**9.树的高度或深度：树中结点的最大层次。**假设我们从1开始算树的高度，那么上图树结构树的高度为4，若是从0开始则树的高度为3。



特别注意：
  算树的高度有两种情况：**一种是从0开始计算高度，另一种则是从1开始计算高度**，两者最后计算出的树的高度会有所不同。

  建议从1开始算树的高度，因为当树结构为空时，0可以更好表示空树，而如果从0开始计算树的高度则会出现空树用负数定义，不好表示（但也仅是如此，只是建议）。

10.堂兄弟结点：双亲在同一层的结点互为堂兄弟。比如：上图树结构H、I为堂兄弟结点。

11.结点的祖先：从根到该结点所经分支上的所有结点。比如：上图树结构A结点是所有结点的祖先。

12.子孙：以某结点为根的子树中任意结点都被称为该结点的子孙。比如：上图树结构所有结点都是A结点的子孙。

13.森林：由m(m > 0)棵互不相交的树的集合称为森林。（之后数据结构会有体现）。



## 二、树的特点  

  树是一种**非线性**的数据结构，它是由n(n >= 0)个有限结点组成一个具有层次关系的集合，把它叫做树是因为它看起来像一棵倒挂的树，也就是说他的根朝上，而叶朝下。

  ①有一个特殊的结点。称为根结点。根结点没有前驱结点。

  ②除根结点外，其余结点被分成M(M > 0)个互不相交的集合T1、T2、....... 、Tm，其中每一个集合Ti（1 <= i <= m）又是一棵结构与树类似的子树，每棵子树的根结点有且只有一个前驱，可以有0个或多个后驱。

  ③因此，**树是递归定义**的。（比如斐波那契数列，它的递归结构就相当于树）

   注意：树形结构中，子树之间不能有交集，否则不能称为树结构。（如下图所示）

![](C:\Users\34289\Desktop\learning\code learning material\数据结构与算法\数据结构（初阶）示意图\不是树的例子.png)

## 三、二叉树



### 3.1概念

一棵二叉树是结点的有限结合，该集合：

  1：或者为空

  2：由一个根结点加上两棵别称为左子树和右子树的二叉树组成



![](C:\Users\34289\Desktop\learning\code learning material\数据结构与算法\数据结构（初阶）示意图\二叉树示意图.png)

![](C:\Users\34289\Desktop\learning\code learning material\数据结构与算法\数据结构（初阶）示意图\介绍二叉树.png)

由上图可知：
  1.二叉树中不存在大于2的结点

  2.二叉树的子树有左右之分，次序不能颠倒，因此二叉树是有序树

注意：对于任意的二叉树都是由一下集中情况复合而成的：

![](C:\Users\34289\Desktop\learning\code learning material\数据结构与算法\数据结构（初阶）示意图\二叉树的种类.png)

### 3.2 特殊的二叉树

1**.满二叉树**：一个二叉树，如果每一个结点树都达到了最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为k，且结点总数为2^k - 1，那么它就是满二叉树。

2**.完全二叉树**：完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。对于深度为k的，有n个结点的二叉树，当且仅当每一个结点都与深度为k的满二叉树中编号从1至n的结点——对应时称完全二叉树。需要注意的时满二叉树是一种特殊的完全二叉树。

注意：**完全二叉树是连续的**。

![](C:\Users\34289\Desktop\learning\code learning material\数据结构与算法\数据结构（初阶）示意图\特殊的二叉树.png)



栈：线性表，后进先出

堆：非线性表，完美二叉树

小堆：树中的任意一个父亲结点都 <= 子节点

大堆：树中的任意一个父亲结点都 >= 子节点





### 3.3 二叉树的存储方式

#### 1、用顺序表存储

![](C:\Users\34289\Desktop\learning\code learning material\数据结构与算法\数据结构（初阶）示意图\二叉树的存储.png)

#### 2、用链表存储

二叉树的链表结构：

```C
struct BinaryTree`

`{`

    `int val;`

    `struct BinaryTree* left;`

    `struct BinaryTree* right;`

`};`
```



### 3.4 二叉树的性质

1、若规定根结点的层数为1，则一棵非空二叉树的**第i层上最多有2^(i - 1)**个结点。

2、若规定根结点的层数为1，则**深度为h的二叉树的最大结点数是2^h - 1**。

3、对任意一棵二叉树，**如果度为0其叶结点个数为n0，度为2的分支结点个数为n2，则n0 = n2 + 1**。

4、若规定根结点的层数为1，**具有n个结点的满二叉树的深度，h = log2 (n + 1)** ( log2 (n + 1) 表示为log以2为底，n + 1为对数)。

5、对于具有n个结点的完全二叉树，如果按照从上至下从左至右的数组顺序对所有结点从0开始编号，则对于序号为i的结点有：

①**若i > 0，i位置的结点的双亲序号：(i - 1) / 2**； i = 0，i为根结点编号，无双亲结点。

②**若2i + 1 < n，左孩子序号：2i + 1，2i + 1 >= n否则无左孩子**。

③**若2i + 2 < n,   右孩子序号：2i + 2,   2i + 2 >=n否则无右孩子**。



### 3.5 二叉树的遍历

#### 1、前序、中序、后序遍历

 	 学习二叉树结构，最简单的方式就是遍历。所谓**二叉树遍历（Traversal）是按照某种特定的规则，依次对二叉树中的结点进行相应的操作，并且每个结点只操作一次**。访问结点所做的操作依赖于具体的应用问题。遍历是二叉树上最重要的运算之一，也是二叉树上进行其他运算的基础。



按照规则，二叉树的遍历有：**前序、中序、后序的递归结构遍历**：

1.前序遍历（Preorder Traversal）：访问根结点的操作发生在遍历其左右子树之前。

2.中序遍历（Inorder Traversal）：访问根结点的操作发生在遍历其左右子树之中（间）。

3.后序遍历（Postorder Traversal）：访问根结点的操作发生在遍历其左右子树之后。



*深度优先搜索（DFS）：前序遍历  通常以递归的形式完成

*广度优先搜索（BFS）：层序遍历 通常需要队列去配合



# 7.排序

## 1、排序的概念及其运用

### 1.1排序的概念

**排序**：所谓排序，就是使一串记录，按照其中的某个或某些关键词的大小，递增或递减的排列起来的操作。

**稳定性**：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中。r[i] = r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍然在r[j]之前，则称这种排序算法是稳定的，否则称为不稳定的。

**内部排序**：数据元素全部放在内存中的排序。

**外部排序**：数据元素太多不能同时放在内存中，根据排序过程的要求不能放在内外层之间移动的排序。



### 1.2稳定性的意义

**1.对于需要排序的数据要求并不仅仅只限于数据。**



比如在考试中我们需要取成绩前三名的同学，这个时候我们将考试分数进行排序，但是满足要求的前三名同学需要做到分数和时间都要最优，这个时候稳定性就有意义了，比如说现在有四个人的成绩，第一个交卷的得了99分，第二个交卷的得了98分，第三个交卷的得了99分，第四个交卷的得了98分。如果使用稳定的排序进行结果处理，毫无疑问第一名一定是第一个交卷的，第二名一定是第三个交卷的，第三名一定是第二个交卷的。因为排序的稳定性直接导致在分数相同的情况下，时间用时最短的一定在最前面。但如果说不考虑排序的稳定性的话，那么就可能会出现分数相同但时间耗时更多的排名更先，这样并不符合我们所需要的排序要求。



## 2、常见排序算法的实现

### 2.1插入排序

直接插入排序是一种简单的插入排序法，其基本思想是：

**把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的记录插完为止，得到一个新的有序序列。**

实现代码：

```c
//nums为一维数组，n为数组元素个数
void InsertSort(int* nums, int n)
{
	for (int i = 0; i < n - 1; i++)
	{
		int end = i;
		int temp = nums[end + 1];
		while (end >= 0)
		{
			if (temp < nums[end])
			{
				nums[end + 1] = nums[end];
			}
			else
			{
				break;
			}
          
			end--;
		}
		nums[end + 1] = temp;
	}
}
```

时间复杂度：O(N^2)

空间复杂度：O(1)

稳定性：稳定



### 2.2希尔排序

希尔排序主要分为两个步骤：**预排序**和**直接插入排序**。

预排序：分组排，间隔为gap分为一组。



**预排序意义**：大的数可以更快的到后面去，小的数可以更好的到前面去（此为升序情况，降序则正好相反），gap**越大**跳的**越快**，但是**越不接近有序**，而gap**越小**跳的**越慢**，但是**越接近有序**。当gap == 1时，直接就是有序的。



实现代码：

```C
void ShellSort(int* nums, int n)
{
	/*当gap > 1时都是预排序，当gap == 1时是实排序（插入排序,时间复杂度为O(N)）*/
	int gap = n;
	while (gap > 1)
	{
		//gap /= 3 + 1,两种写法
		gap /= 2;
		for (int i = 0; i < n - gap; i++)
		{
			int end = i;
			int temp = nums[end + gap];
			while (end >= 0)
			{
				if (temp < nums[end])
				{
					nums[end + gap] = nums[end];
					end -= gap;
				}
				else
				{
					break;
				}
			}
			nums[end + gap] = temp;
		}
	}
}
```

时间复杂度：就现在位置对希尔排序的时间复杂度并没有一个明确的说法，但普遍认为时O(N^1.3)

空间复杂度：O(1)

稳定性：不稳定



### 2.3堆排序



实现代码:

```C
typedef int HPDataType;

typedef struct Heap
{
	HPDataType* _a;
	int _size;
	int _capacity;
}HP;

void swap(HPDataType* child, HPDataType* parents)
{
	HPDataType temp = 0;
	temp = *child;
	*child = *parents;
	*parents = temp;
}

void Adjustment_up(HPDataType* a, int child)
{
	int parents = (child - 1) / 2;
	while (child > 0)
	{
		if (a[child] < a[parents])
		{
			swap(&a[child], &a[parents]);
			child = parents;
			parents = (child - 1) / 2;
		}
		else
		{
			break;
		}
	}
}

void Adjustment_down(HPDataType* a, int n, int parents)
{
	int child = parents * 2 + 1;
	while (child < n)
	{
		/*需要满足child + 1 < n是因为完全二叉树可能出现双亲结点只有一个子节点的情况，避免出现比较不存在的数据*/
		if (child + 1 < n && a[child] < a[child + 1])
		{
			child++;
		}

		if (a[child] > a[parents])
		{
			swap(&a[child], &a[parents]);
			parents = child;
			child = parents * 2 + 1;
		}
		else
		{
			break;
		}
	}
}

void HeapSort(HPDataType* a, int num)
{
     /*降序（建小堆）*/
	/*时间复杂度：O(N*logN)*/
	//int i = 0;
	//for (i = 0; i < num; i++)
	//{
	//	Adjustment_up(a, i);
	//}
	for (int i = (num - 2) / 2; i >= 0; i--)
	{
		Adjustment_down(a, num, i);
	}

	/*for (i = 0; i < num; i++)
	{
		printf("%d ",a[i]);
	}
	printf("\n");*/

	/*建好大堆以后，将第一个数据与最后一个数据进行交换，然后将这个交换的数据进行向下调整进行排序*/
	int end = num - 1;
	while (end > 0)
	{
		swap(&a[0], &a[end]);
		Adjustment_down(a, end, 0);
		end--;
	}
}
```

堆排序的实现原理：

先将需要进行排序的数据元素用二叉树以顺序表的形式存储好，然后对其进行建堆处理。如果需要的是**升序排序**的话，则先**建立大堆**，然后再进行向下排序，**降序排序**的话则正好相反，先**建立小堆**然后再进行向下排序。



时间复杂度：O(N*logN)

空间复杂度：O(1)

稳定性：不稳定



### 2.4冒泡排序

冒泡排序的基本原理：遍历与交换
遍历：一个一个访问

例：16 25 9 90 23
降序排列-从大到小

第一轮循环
某个数字小于后面的数字，那么就交换
1.      25 16 9 90 23       （16和25进行比较并进行交换）
2.      25 16 9 90 23       （16和9进行比较并进行交换，但16>9，所以情况和1相同）
3.      25 16 90 9 23       （9和90）
4.      25 16 90 23 9        （23和9）
特点：①需要比较多轮      （数组长度减1）轮
②第一轮比较了4次 ，每一轮比较的次数比上一次-1次    （数组长度 - 1） - 当前的轮数

外层循环控制 轮数         （通常用i表示）
内层循环控制 每轮的比较次数      （通常用j表示）



实现代码（优化版）：

```C
void BubbleSort(int* nums, int n)
{
	for (int i = 0; i < n - 1; i++)
	{
		/*如果这个数组里的元素已经是有序的则直接跳出循环*/
		int exchange = 0;
		for (int j = 0; j < n - i - 1; j++)
		{
			if (nums[j] > nums[j + 1])
			{
				swap(&nums[j], &nums[j + 1]);
				exchange = 1;
			}
		}
		if(exchange == 0)
		{
			break;
		}
	}
}

```

时间复杂度：O(N^2)

空间复杂度：O(1)

稳定性：稳定



### 2.5选择排序

实现代码：

```C
void swap(int* left, int* right)
{
	int temp = *left;
	*left = *right;
	*right = temp;
}

void SelectSort(int* nums, int n)
{
	int begin = 0, end = n - 1;
	while (begin < end)
	{
		int max_index = begin, min_index = begin;
		for (int i = begin + 1; i <= end; i++)
		{
			if (nums[i] > nums[max_index])
			{
				max_index = i;
			}
			if (nums[i] < nums[min_index])
			{
				min_index = i;
			}
		}

		swap(&nums[begin], &nums[min_index]);
		/*防止最大的元素刚好就在最小元素的下标中导致排序失败*/
		if (max_index == begin)
		{
			max_index = min_index;
		}
		swap(&nums[end], &nums[max_index]);
		begin++;
		end--;
	}
}
```

选择排序的原理：

选择排序过程先从数组两头开始，先建立两个变量存储所需要排序的数组的**元素头(begin)和元素尾(end)**，随后开始本轮排序。先假定最大和最小元素的下标都是该轮排序的头元素，然后依次遍历整个数组**（已经确定好的元素不需要遍历）**，**如果出现比该轮最大元素大的或比最小元素小的，都将更新最大元素下标和最小元素下标**。遍历完整个数组后该轮排序结束，并将最大元素和最小元素分别通过该轮排序所获得的最大元素下标和最小元素下标放入先前建立好的元素头(begin)和元素尾(end)。然后移动这两个变量(begin++ end--)开始下一轮排序，直到数组有序为止(begin > end)。

时间复杂度：O(N^2)

空间复杂度：O(logN)

稳定性：不稳定



### 2.6快速排序

快速排序原理：

任取待排元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两个子序列，左子序列中所有元素均小于基准值，右子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止。



实现代码（霍尔实现的方法）:

```c
int GetMiddle(int* nums, int left, int right)
{
	int middle = (right + left) / 2;
	if (nums[left] > nums[middle])
	{
		if (nums[left] > nums[right])//nums[left]最大
		{
			if (nums[middle] > nums[right])
			{
				return right;
			}
			else
			{
				return middle;
			}
		}
		else//left比middle大，比right小
		{
			return left;
		}
	}
	else
	{
		if (nums[middle] > nums[right])//middle最大
		{
			if (nums[left] > nums[right])
			{
				return right;
			}
			else
			{
				return left;
			}
		}
		else //middle比left大，比right小
		{
			return middle;
		}
	}
}

int PartSort(int* nums, int left, int right)
{
	/*三数取中*/
	int middle = GetMiddle(nums, left, right);
    swap(&nums[left], &nums[middle]);
	/*每一次执行该排序就确定了数组key_i下标的元素*/
	int key_i = left;
	//int* key_i = nums[left];
	while (left < right)
	{
		/*先从右边开始找*/
		/*找小*/
		while (left < right && nums[right] >= nums[key_i])
		{
			--right;
		}

		/*找大*/
		while (left < right && nums[left] <= nums[key_i])
		{
			++left;
		}
		swap(&nums[left], &nums[right]);
	}

	swap(&nums[key_i], &nums[left]);
	return left;
}


void QuickSort(int* nums, int begin, int end)
{
	if (begin >= end)
	{
		return;
 	}

	int key_i = PartSort(nums, begin, end);
	QuickSort(nums, begin, key_i - 1);
	QuickSort(nums, key_i + 1, end);
}
```

时间复杂度：O(N*logN)

空间复杂度：O(1)

稳定性：不稳定



**注意写这串代码时有三个坑：**

一、左右两个元素相等导致死循环（解决办法：例nums[right] >= nums[key_i]，注意要加等于号）
二、该数组元素就是有序导致越界访问（解决办法：前面加上left < right &&）
三、如果key直接存的就是数组元素的话，由于是局部变量导致交换失败（解决办法：key值存下标或者用指针存数组元素）



**优化：**

1、如果快速排序正好排的就是一个有序数组，那么时间复杂度就会变成O(N^2)，效率将会非常低下，所以这时需要用到**三数取中**，将中间大的值和key值进行交换，重新将时间复杂度调正到O(N*logN)。（优化代码写入上述实现代码）

2、小区间优化：如果此时排序已经到小区间时，就不用递归继续排序，而是直接使用插入排序，降低递归使用次数。

小区间优化代码：

```C
void QuickSort(int* nums, int begin, int end)
{
	
	if (begin >= end)
	{
		return;
 	}

	//小区间优化：如果此时排序已经到小区间时，就不用递归继续排序，而是直接使用插入排序，降低递归使用次数
	if (end - begin + 1 > 10)
	{
		int key_i = PartSort_3(nums, begin, end);
		QuickSort(nums, begin, key_i - 1);
		QuickSort(nums, key_i + 1, end);
	}
	else
	{
		InsertSort(nums + begin, end - begin + 1);
	}
}
```

`3、三路归并：如果出现数组元素全部为一个值或者大部分元素都是一个值的时候，上述两个优化仍然不能解决问题，时间复杂度仍然非常高，所以这时我们需要**三路归并**思想，将值数相等的所有元素放在中间。

优化代码：

```c
void QuickSort_2(int* nums, int left, int right)
{
	if (left >= right)
	{
		return;
	}

	int middle = GetMiddle(nums, left, right);
	swap(&nums[middle], &nums[left]);
	int key = nums[left];
	int begin = left, end = right, cur = left + 1;
	while (cur <= right)
	{
		if (nums[cur] < key)
		{
			swap(&nums[cur], &nums[left]);
			++left;
			++cur;
		}
		else if(nums[cur] == key)
		{
			++cur;
		}
		else
		{
			swap(&nums[cur], &nums[right]);
			--right;
		}
	}

	//[begin, left - 1] [left, right] [right + 1, end]
	QuickSort_2(nums, begin, left - 1);
	QuickSort_2(nums, right + 1, end);
}
```



但是但是，这三个优化**仍然过不了**leetcode的一道题：[912. 排序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-an-array/)

写这道题需要再次优化三数取中，将初始key值的取值范围定位left和right区间里的随机一个，而不是只靠三个数取中间获取key值。（总之我直接qsort过了就是）



快速排序实现的**疑惑点**：

##### 一、假设key值取的是数组的最左边元素，为什么在相遇地方的值永远比key值小？

答：因为在快速排序中**永远是右边先动**

假设我们用**left_index**和**right_index**分别从数组的头尾出发，他们分别表示数组元素的下标，且每次都是右边先动。

在快速排序中，只会有两种情况，一种是**右边动而左边不动，导致右边主动与左边相遇**（right_index主动与left_index相遇）。另一种是**左边动而右边不动，导致左边主动与右边相遇**（left_index主动与right_index相遇）。



如果是第一种情况的话，那么可知在**上一次交换中，left_index所指向的值已经和right_index所指向的值进行交换了，现在left_index所指向的值比key小，此时left_index不动**。那么此时right_index主动和left_index相遇，自然共同所指向的值比key值小。



如果是第二种情况的话，右边停止的原因**是right_index所指向的值已经是比key值要小的值**。所以此时left_index主动与right_index相遇，共同指向的值也要比key值小。



当然也有其他方式的快速排序方法：

#### **1、挖坑法（思路和霍尔的方法类似）**

```C
int PartSort_2(int* nums, int left, int right)
{
	/*三数取中*/
	int middle = GetMiddle(nums, left, right);
	swap(&nums[left], &nums[middle]);
	int key = nums[left];
	/*int hole = left;*/
	while (left < right)
	{
		while (left < right && nums[right] >= key)
		{
			--right;
		}
		/*nums[hole] = nums[right];
		hole = right;*/
		nums[left] = nums[right];

		while (left < right && nums[left] <= key)
		{
			++left;
		}
		/*nums[hole] = nums[left];
		hole = left;*/
		nums[right] = nums[left];
	}
	nums[left] = key;
	/*nums[hole] = key;*/
	return left;
}
```

实现原理：

与霍尔的方法不同，先取出key值，并将key所指向的下标设为坑。还是先从右边出发，如果右边的下标指向的值比key值小，那么此时右边访问的值将直接给目前坑的位置，然后右边下标此时的值设为坑，然后左边出发，如果左边的下标指向的值比key值大，那么此时左边访问的值将直接给目前坑的位置，然后左边下标此时的值设为坑。以此类推，直到左右下标相遇，而相遇时此时下标所指向的正是坑，此时将key值放入坑中结束该轮排序。



#### **2、前后指针法**

```C
int PartSort_3(int* nums, int left, int right)
{
	/*三数取中*/
	int middle = GetMiddle(nums, left, right);
	swap(&nums[left], &nums[middle]);

	int key_i = left;
	int prev = left, cur = prev + 1;
	while (cur <= right)
	{
		if (nums[cur] < nums[key_i] && ++prev != cur)
		{
			swap(&nums[prev], &nums[cur]);
		}

		/*if (nums[cur] < nums[key_i])
		{
			++prev;
			if (nums[prev] > nums[key_i])
			{
				swap(&nums[prev], &nums[cur]);
			}
		}*/
		++cur;
	}
	swap(&nums[prev], &nums[key_i]);
	return prev;
}
```

实现原理：

同样先找出key值，然后先设立两个指针，初始化两个指针一个prev指向最左边的值，cur则指向prev所指向的值的下一个值。循环过程为：每次循环中，如果此时cur所指向的值比key值要小的话，prev都会向后移动一格，又如果prev移动之后不和cur相遇，此时prev和cur指向的值进行交换。（这步原因是只有当cur访问到了比key值大的时候，prev才不会紧跟在cur之后，而在下一次cur指向比key值小的值后，此时prev指向的正好是比key值大的值，从而实现小数往右靠，大数往做靠的功能），最后cur往后移动一格（每次循环都会）。



#### **3、非递归方式实现快速排序（利用栈实现）**

```C
void QuickSortNonR(int* nums, int begin, int end)
{
	ST s;
	StackInit(&s);
	StackPush(&s, end);
	StackPush(&s, begin);
	while (!StackEmpty(&s))
	{
		int left = StackTop(&s);
		StackPop(&s);

		int right = StackTop(&s);
		StackPop(&s);

		int key_i = PartSort_1(nums, left, right);
		if (key_i + 1 < right)
		{
			StackPush(&s, right);
			StackPush(&s, key_i + 1);
		}

		if (key_i - 1 > left)
		{
			StackPush(&s, key_i - 1);
			StackPush(&s, left);
		}
	}
}
```

实现原理：



### 2.7归并排序

**基本思想**：
归并排序（MEGRE-SORT）是建立在归并的操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路合并。



实现代码（递归版本）：

```C
void _MergeSort(int* nums, int* temp, int begin, int end)
{
	if (end <= begin)
	{
		return;
	}

	int mid = (begin + end) / 2;
	/*递归过程*/
	//不可以是注释这么写，不然会进入无限递归
	/*_MergeSort(nums, temp, begin, mid - 1);
	_MergeSort(nums, temp, mid, end);*/
	_MergeSort(nums, temp, begin, mid);
	_MergeSort(nums, temp, mid + 1, end);

	/*递归完成开始排序*/
	int begin_1 = begin, end_1 = mid;
	int begin_2 = mid + 1, end_2 = end;
	/*访问temp数组的下标*/
	int index = begin;
	while (begin_1 <= end_1 && begin_2 <= end_2)
	{
		if (nums[begin_1] < nums[begin_2])
		{
			temp[index++] = nums[begin_1++];
		}
		else
		{
			temp[index++] = nums[begin_2++];
		}
	}

	while (begin_1 <= end_1)
	{
		temp[index++] = nums[begin_1++];
	}
	while (begin_2 <= end_2)
	{
		temp[index++] = nums[begin_2++];
	}

	memcpy(nums + begin, temp + begin, sizeof(int) * (end - begin + 1));
}

void MergeSort(int* nums, int n)
{
	int* temp = (int*)malloc(sizeof(int) * n);
	if (temp == NULL)
	{
		perror("malloc fail\n");
		exit(-1);
	}

	_MergeSort(nums, temp, 0, n - 1);
	free(temp);
}
```



实现代码（非递归版本）：

```C
void MergeSortNonR(int* nums, int n)
{
	int gap = 1;
	int* temp = (int*)malloc(sizeof(int) * n);
	if (temp == NULL)
	{
		perror("malloc fail\n");
		exit(-1);
	}

	while(gap < n)
	{
		for (int i = 0; i < n; i += 2 * gap)
		{
			int begin_1 = i, end_1 = i + gap - 1;
			int begin_2 = i + gap, end_2 = i + 2 * gap - 1;
			int index = i;

			//如果end_1,begin_2都比n要大的话，说明最后的那一组数据完全没有必要归并，直接在最后一起归并即可
			if (begin_2 >= n)
			{
				break;
			}
			//如果只是end_2比n大的话，说明即将进行最后一次归并，这次归并直接将最后一组数据一起归并即可
			if (end_2 >= n)
			{
				end_2 = n - 1;
			}

			while (begin_1 <= end_1 && begin_2 <= end_2)
			{
				if (nums[begin_1] < nums[begin_2])
				{
					temp[index++] = nums[begin_1++];
				}
				else
				{
					temp[index++] = nums[begin_2++];
				}
			}

			while (begin_1 <= end_1)
			{
				temp[index++] = nums[begin_1++];
			}
			while (begin_2 <= end_2)
			{
				temp[index++] = nums[begin_2++];
			}
			memcpy(nums + i, temp + i, sizeof(int)*(end_2 - i + 1));
		}
		gap *= 2;
	}
	free(temp);
}
```

理解示意图：
![](C:\Users\34289\Desktop\learning\code learning material\数据结构与算法\数据结构（初阶）示意图\归并排序示意图.png)

时间复杂度：O(N*logN)

空间复杂度：O(N)

稳定性：稳定

### 2.8非比较排序

思想：计数排序又叫鸽巢原理，是对哈希直接定址的变形应用。

操作步骤：

1.统计相同元素出现的次数

2.根据统计的结果将序列回收到原来的序列

实现代码：

```C
void CountSort(int* nums, int n)
{
    //找出数据中的最小值和最大值，确定需要开辟的数组大小
	int min = nums[0], max = nums[0];
	for (int i = 0; i < n; i++)
	{
		if (nums[i] < min)
		{
			min = nums[i];
		}
		if (nums[i] > max)
		{
			max = nums[i];
		}
	}
    
	int range = max - min + 1;
	int* count = (int*)malloc(sizeof(int) * range);
	if (count == NULL)
	{
		perror("malloc fail\n");
		exit(-1);
	}
	memset(count, 0, sizeof(int) * range);

    //统计每个数一共出现了多少次（使用相对映射放入数据，如数据200则在count数组中下标为200-min的地方放置）
	for (int i = 0; i < n; i++)
	{
		count[nums[i] - min]++;
	}

    //排序，根据count数组计数的多少确定数据的个数完成排序
	int j = 0;
	for (int i = 0; i < range; i++)
	{
		while (count[i]--)
		{
			nums[j++] = i + min;
		}
	}
}
```

**特点：适合数据范围集中的排序,且只适合整型**

时间复杂度：O(n + range)

空间复杂度：O(range)

## 3、排序分类

排序可分为**内排序（在内存中牌序）**和**外排序（在磁盘中排序）**,而以上所有讲的排序都可以称为内排序，但是**归并排序**可以作为外排序。

